<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Apache Flink 大状态管理：增量 checkpointing 介绍 › Coco&#39;s Mark</title>
  <meta name="author" content="coco">
  
  <meta name="description" content="Apache Flink 专门为状态流（stateful stream）计算而搭建。那什么是流计算中的状态（state）？我在上一篇博客中定义了状态和状态流计算，简单回顾一下：状态是被定义在算子（operator）中的一块内存空间，通过存储过去事件中的信息来影响未来事件的处理。">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="Apache Flink 大状态管理：增量 checkpointing 介绍"/>
  <meta property="og:site_name" content="Coco&#39;s Mark"/>

  
    <meta property="og:image" content=""/>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Coco&#39;s Mark" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  

<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header id="header"><div class="meta inner">
  <h1><a href="/">Coco&#39;s Mark</a></h1>
  <h2><a href="/">持续专注于实时技术领域</a></h2>
  <nav id="main-nav">
    <ul>
      
      <li><a href="/about">About</a></li>
      
      <li><a href="/archives">Archives</a></li>
      
      <li><a href="/atom.xml">RSS</a></li>
      
    </ul>
    <div class="clearfix"></div>
  </nav>
</div>
<div class="clearfix"></div>
</header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper"><article class="post">
  <div class="post-content">
    <header>
      
  
    <h1 class="title">Apache Flink 大状态管理：增量 checkpointing 介绍</h1>
  

      
        <time datetime="2021-08-20T16:00:00.000Z">2021-08-21</time>
        <span>coco</span>
      
    </header>
    <div class="entry">
      
        <p>Apache Flink 专门为<strong>状态流（stateful stream）</strong>计算而搭建。那什么是流计算中的<strong>状态（state）</strong>？我在<a target="_blank" rel="noopener" href="http://flink.apache.org/features/2017/07/04/flink-rescalable-state.html">上一篇博客</a>中定义了状态和状态流计算，简单回顾一下：状态是被定义在<strong>算子（operator）</strong>中的一块内存空间，通过存储过去事件中的信息来影响未来事件的处理。</p>
<span id="more"></span>

<p>在一些常见的复杂流计算场景中状态是一个基本且必要的概念。以下是<a target="_blank" rel="noopener" href="https://ci.apache.org/projects/flink/flink-docs-release-1.3/dev/stream/state.html">Flink 官方文档</a>中提到的几个经典场景：</p>
<ul>
<li><p>当需要在应用中寻找特定格式的事件时，需要依赖状态来存储输入的事件序列</p>
</li>
<li><p>当需要按分钟进行数据聚合时，需要依赖状态来存储聚合过程的中间结果</p>
</li>
<li><p>当需要通过数据集训练机器学习模型时，需要依赖状态存储当前版本的模型参数</p>
</li>
</ul>
<p>然而，状态流只有支持状态<strong>容错（fault tolerant）</strong>才能在实际生产过程中发挥其真正价值。“容错”意味着即使在软件或硬件层面出现了异常也不会影响最终结果的准确性，即：没有数据丢失和重复数据情况发生。</p>
<p>容错机制一直是 Flink 强大且著名的特性。该特性能够将软件或硬件异常带来的影响降到最低，并且 Flink 应用内保证了<strong>精确一次（exactly-once）</strong>语义的结果。</p>
<p>Flink 实现容错的核心机制是 <a target="_blank" rel="noopener" href="https://ci.apache.org/projects/flink/flink-docs-release-1.3/dev/stream/checkpointing.html">checkpointing</a>。checkpinting 是一次全局的、异步的应用状态快照生成的过程，该过程被周期性的触发，最终写入到可靠的存储中（通常为分布式文件系统）。当异常发生时，Flink 使用最近一次完成的 checkpoint 作为状态的初始点来重启应用。一些开发者的 Flink 应用会产生 GB 甚至 TB 级别的状态，这些开发者反馈，在大状态下制作 checkpoint 是一个缓慢且资源密集型的操作，正因如此我们在 Flink 1.3 中提出了<strong>“增量快照（incremental checkpoint）”</strong>。</p>
<p>在没有引入增量 checkpointing 之前，每次 checkpoint 不得不包含 Flink 应用的全部状态。我们注意到从上个 checkpoint 到下个 checkpoint 期间状态的改变通常比较小，往往没有必要对全部状态制作 checkpoint，为此我们引入了增量 checkpointing。不同于全量 checkpointing，增量 checkpointing 仅包含与上次 checkpoint 不同（或增量）的部分，并存储这些不同（或增量）的内容。</p>
<p>大状态场景下，增量 checkpointing 给性能带来了巨大的提升。之前生产环境的测试结果中，TB 级别的状态在增量 checkpointing 使用前后 checkpoint 时间从原来的 3mins 下降到 30s。这得益于 checkpoint 不再需要将全部的状态上传到持久化的存储中。</p>
<h1 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h1><p>当前 Flink 仅支持在 RocksDB 状态后端中使用增量 checkpointing，Flink 借助了 RocksDB 内部备份机制来定期对 checkpoint 进行整理。正因如此，增量 checkpoint 的历史记录不会无限制的增长下去，Flink 会自动的消耗和修剪旧的 checkpoints。</p>
<p>关于增量 checkpointing 的开启，<a target="_blank" rel="noopener" href="https://ci.apache.org/projects/flink/flink-docs-release-1.4/ops/state/large_state_tuning.html#tuning-rocksdb">Apache Flink 的 checkpointing 官方文档</a>中有更详细的介绍。简单来说，你需要正常开启 checkpointing，并在创建 RocksDB 状态后端实例时将构造器的第二个参数设置为<code>true</code>。</p>
<pre><code class="hljs java">StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();

env.setStateBackend(newRocksDBStateBackend(filebackend, <span class="hljs-keyword">true</span>));</code></pre>

<pre><code class="hljs scala"><span class="hljs-keyword">val</span> env = <span class="hljs-type">StreamExecutionEnvironment</span>.getExecutionEnvironment()

env.setStateBackend(newRocksDBStateBackend(filebackend, <span class="hljs-literal">true</span>))</code></pre>

<p>默认情况下，Flink 仅保留 1 个已完成的 checkpoint，如果需要保留更多，<a target="_blank" rel="noopener" href="https://ci.apache.org/projects/flink/flink-docs-master/docs/dev/datastream/fault-tolerance/checkpointing/">可以通过以下配置</a>：</p>
<pre><code class="hljs plaintext">state.checkpoints.num-retained</code></pre>

<h1 id="内部机制"><a href="#内部机制" class="headerlink" title="内部机制"></a>内部机制</h1><p>Flink 增量 checkpointing 是以 <a target="_blank" rel="noopener" href="https://github.com/facebook/rocksdb/wiki/Checkpoints">RocksDB checkpoints</a> 为基础实现的。RocksDB 底层基于“<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Log-structured_merge-tree">log-structured-merge（LMS）</a>”树形结构实现，它在内存中维护了一个被称作“memtable”的<strong>可变的内存缓冲区（changeable in-memory buffer）</strong>，key 相同的数据被更新时原 value 会被覆盖。当 memtable 写满时会将数据按照 key 顺序写入到磁盘中，写入过程中还会对数据进行轻量级的压缩。一旦数据写入到磁盘中，该数据将不可改变，此时的数据结构被称为<strong>“sorted-string-table（sstable）”</strong></p>
<p>RocksDB 会启动一个后台任务来将重复的 key 进行整理、合并成新的 sstables，旧的 sstables 将被删除，合并后的 sstable 会包含之前所有数据。</p>
<p>在此之上，Flink 会追踪自上次 checkpoint 之后哪些 sstables 被创建或被删除。得益于 sstables 的不可变性，Flink 得以掌握 state 的变化。在 checkpoint 触发时，Flink 会将所有的 memtables 数据强制写入磁盘中，并在本地临时目录中创建一个<strong>硬链接（hard-link）</strong>。这个过程会发生短暂的同步阻塞，而后 checkpoint 的其他制作阶段都是异步完成的，不再有阻塞发生。</p>
<p>接着 Flink 将新生成的 sstables 拷贝到持久化的存储中（如 HDFS、S3），新 checkpoint 将为它们创建引用。Flink 并不是将现有所有的 sstables 全部拷贝到持久化存储，而是让新 checkpoint 再次引用它们。新 checkpoint 不会引用已删除的文件，因为 RocksDB 的合并过程最终会生成新的 sstable 来替代旧 sstables，旧文件最终会随着压缩合并过程被删除。增量 checkpoints 历史记录也因此得以被修剪。</p>
<p>为了追踪 checkpoints 之间的变化，Flink 需要将 RocksDB 压缩合并后的 sstables 上传到持久化存储中，这其中包含了部分冗余的内容。但由于 Flink 是增量式处理，所以这部分工作带来的开销很小，而且压缩后更少的 checkpoint 历史记录也利于 checkpoint 恢复，正因如此我们认为这样做是值得的。</p>
<h1 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h1><p><img src="/img/incremental_cp_impl_example.svg" alt="增量 checkpoint 示例图"></p>
<p>示例中包含了一个<strong>算子（Operator）</strong>中的某个 subtask<em>（假定 operator id 为 2，subtask id 为 1，对应 op-2-1，译者注）</em>，这个算子中包含了 keyed state，另外 checkpoint 保留数配置为 <strong>2</strong>。上图中每一列分别表示：</p>
<ol>
<li><p>每次 checkpoint 时本地 RocksDB 包含的 sstables 文件情况；</p>
</li>
<li><p>checkpoint 对持久化存储中备份文件的引用记录；</p>
</li>
<li><p>状态<strong>共享注册表（shared state registry）</strong>用于当 checkpoint 完成时统计文件引用的次数；</p>
</li>
<li><p>checkpoints 保留情况。</p>
</li>
</ol>
<p>在制作 checkpoint “CP 1”时，本地 RocksDB 目录下包含了 2 个 sstables 新文件，这两个新文件将被上传到持久化存储中，目录名称与 checkpoint 名称相匹配。当 checkpoint 完成后，Flink 会在状态共享注册表中新增两条记录，并将引用数量设为 1。注册表中的 key 是通过 operator、subtask、sstables 名称共同组合而成。注册表中同时还保存了 key 到持久化存储路径的映射<em>（即图中第二列，译者注）</em>。</p>
<p>“CP 2”阶段，RocksDB 又新生成了 2 个 sstables 文件，原来的 2 个旧文件仍然存在。制作 “CP 2”时，Flink 会先将新 sstables 文件上传到持久化存储中，然后再将 2 个旧文件引用到“CP 2”<em>（旧文件已经在“CP 1”阶段上传到持久化存储中，因此这里只需要添加引用，译者注）</em>。本次 checkpoint 完成后， Flink 将注册表中的引用数加 1。</p>
<p>“CP 3”阶段，RocksDB 完成了 <code>sstable-(1)</code>、 <code>sstable-(2)</code> 和 <code>sstable-(3)</code> 到 <code>sstable-(1,2,3)</code> 的压缩合并，3 个旧的 sstables 文件被删除。此时，<code>sstable-(1,2,3)</code> 包含了之前所有的状态，重复的 entries 已经随着压缩合并过程被覆盖。此外，<code>sstable-(4)</code> 保留了下来，并且生成了新的 <code>sstable-(5)</code>。Flink将新的 <code>sstable-(1,2,3)</code> 和 <code>sstable-(5)</code> 上传，旧的 <code>sstable-(4)</code> 被再次引用。此时 checkpoint 数量达到了设置的上限（上限为 2），Flink 将 “CP 1” 删除，注册表中 “CP 1” 涉及到的引用数减 1（即 <code>sstable-(1)</code> 和 <code>sstable-(2)</code>）。</p>
<p>在 “CP 4”阶段，RocksDB 把 <code>sstable-(4)</code>、<code>sstable-(5)</code> 和新的 <code>sstable-(6)</code> 合并成 <code>sstable-(4,5,6)</code>。Flink 将新的 <code>sstable-(4,5,6)</code> 上传，并与旧的 <code>sstable-(1,2,3)</code> 一起引用到“CP 4”，<code>sstable-(1,2,3)</code> 和 <code>sstable-(4,5,6) </code> 引用数加 1。此时 checkpoint 数量再次达到了上限，将 “CP 2” 删除，同时 <code>sstable-(1)</code>、<code>sstable-(2)</code> 和 <code>sstable-(3)</code> 引用数降到了 0，Flink 将它们从持久化存储中删除。</p>
<h1 id="竞争状态与并发-checkpoints"><a href="#竞争状态与并发-checkpoints" class="headerlink" title="竞争状态与并发 checkpoints"></a>竞争状态与并发 checkpoints</h1><p>Flink 支持并发执行多个 checkpoints，即会存在上个 checkpoint 未完成下个 checkpoint 已开始的情况。因此需要考虑到哪些地方新旧 checkpoint 会同时涉及。Flink 仅在<strong>checkpoint 协调器（checkpoint coordinator）</strong>确认后才会与持久化存储中的文件建立引用关系，因此避免了出现引用已删除文件的情况发生。</p>
<h1 id="checkpoint-恢复与性能考量"><a href="#checkpoint-恢复与性能考量" class="headerlink" title="checkpoint 恢复与性能考量"></a>checkpoint 恢复与性能考量</h1><p>增量 checkpoint 的开启后不需要对状态恢复过程进行额外配置。故障发生时，Flink <code>JobManager</code> 会通知所有 tasks 从上次完成的 checkpoint 中恢复，无论全量 checkpoint 还是增量 checkpoint，每一个 <code>TaskManager</code> 都要从分布式文件系统中下载属于自己的那份状态文件。</p>
<p>尽管增量 checkpoint 特性在大状态场景下极大减少了 checkpoint 的制作时间，但这背后存在着一些权衡。总的来说，增量 checkpoint 减少了一般场景下  checkpoint 制作时间，但同时也带来了更长的恢复时间，具体恢复的时间取决于状态的大小。当集群出现严重异常时，Flink <code>TaskManagers</code> 不得不从多个 checkpoints 中进行恢复，恢复时间会比全量 checkpoint 更长。旧 checkpoints 仍然需要保留，因为新 checkpoint 需要引用它们，这可能导致 checkpoint 变更的历史记录无限的增长下去。你需要准备更多的分布式存储资源来保存它们，同时也需要准备更大的网络带宽来保证读取效率。</p>
<p>有些策略可以帮助你在简便性与性能之间找到更好的权衡点，推荐阅读<a target="_blank" rel="noopener" href="https://ci.apache.org/projects/flink/flink-docs-release-1.4/ops/state/checkpoints.html#basics-of-incremental-checkpoints">Flink 官方文档</a>了解更多的细节。</p>
<p><em>这篇文章<a target="_blank" rel="noopener" href="https://data-artisans.com/blog/managing-large-state-apache-flink-incremental-checkpointing-overview">最初</a><a target="_blank" rel="noopener" href="https://data-artisans.com/blog/managing-large-state-apache-flink-incremental-checkpointing-overview">发表在 Data Artisans 博客</a>中，是由 Stefan Richter 和 Chris Ward 贡献的。</em></p>
<img src="/img/wx_pub.png" width="400" />

<p><em>翻译自 <a target="_blank" rel="noopener" href="https://flink.apache.org/features/2018/01/30/incremental-checkpointing.html">Managing Large State in Apache Flink: An Intro to Incremental Checkpointing</a></em></p>
<p><em>译者：<a href="https://coco-mark.github.io/">可可</a> @ <a href="mailto:cherry.picker2018@icloud.com.">欢迎邮件联系我</a></em></p>

      
    </div>
      
      <footer>
        
  
  <div class="categories">
    <a href="/categories/Flink/">Flink</a>
    
      <span id="busuanzi_container_page_pv" class="alignright">views: <span id="busuanzi_value_page_pv"></span></span>
    
  </div>

        
        
      
      <div class="clearfix"></div>
      </footer>
  </div>
</article>


<section id="comment">
  
</section>


</div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="搜索">
    <input type="hidden" name="q" value="site:coco-mark.github.io">
  </form>
</div>

  
<div class="widget tag">
  <h3 class="title">最新文章</h3>
  <ul class="entry">
    
      <li>
        <a href="/2021/09/05/深入理解 Apache Flink 可扩展状态/">深入理解 Apache Flink 可扩展状态</a>
      </li>
    
      <li>
        <a href="/2021/08/28/Apache Flink：基于 Reactive Mode 的 Flink 自动扩容/">Apache Flink：基于 Reactive Mode 的 Flink 自动扩容</a>
      </li>
    
      <li>
        <a href="/2021/08/21/Apache Flink 大状态管理：增量 checkpointing 介绍/">Apache Flink 大状态管理：增量 checkpointing 介绍</a>
      </li>
    
  </ul>
</div>


  
<div class="widget tag">
  <h3 class="title">分类</h3>
  <ul class="entry">
  
    <li><a href="/categories/Flink/">Flink</a><small>3</small></li>
  
  </ul>
</div>


  
</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2021 coco
  
    <!-- 不蒜子统计 -->
    <span id="busuanzi_container_site_pv">| views: <span id="busuanzi_value_site_pv"></span>,</span>
    <span id="busuanzi_container_site_uv"> visitors: <span id="busuanzi_value_site_uv"></span></span>
  
  
</div>
<div class="alignleft">
 
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>




<!-- Highlight.js -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/googlecode.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/highlight.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>



    <!-- 不蒜子统计 -->
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  
</body>
</html>

